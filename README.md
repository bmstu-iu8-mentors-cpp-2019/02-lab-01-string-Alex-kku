# Лабораторная работа № 1

## Цель
Главная цель данной лабораторной работы научиться создавать пользовательские классы. На простом примере следует изучить как устроенны класс, как создавать методы класса, что такое инкапсуляция, правильно реализовывать конструкторы копирования, операторы присваивания и деструктор. 

## Теоретическая справка
Класс представляет составной тип. Класс в С++ сильно напоминает структуру в С. Более того, класс и структура в С++, ничем практически не отличатся. Единственное отличие в модификаторах доступа по умолчанию. В классе по умолчанию все поля закрытые (`private`), в стуктурах открытые (`public`)  

Следует различать понятия класс и объект (экземпляр класса)

**Класс** описывает свойства и методы, которые будут доступны у **объекта**, построенного по описанию, которое заложенно в классе. Э

**Объект** представляет конкретное воплощение класса.

##### Пример

```cpp
std::string name;
```

`std::string` - это класс;

`name` - это объект. Экземпляр класса `std::string`

### Поля класса

Класс представляет составной тип. Класс, как и структура, может содержать дополнительные поля, члены класса.

Члены класса имеют разный модификатор доступа: `private`, `public`, `protected`.

* `private` - член класса доступен только самому классу. Из вне доступа к этому полю нет. Если попытаться обратиться к закрытому полю, в коде вашей программы, то возникнет **ошибка времени компиляции**.
* `public` - член класса доступен как самому классу, так внешнему по отношению к классу коду.
* `protected` - будет рассмотрен в теме про наследование.


### Указаетль `this`
Ключевое слово `this` представляет указатель на **текущий объект** данного класса. Соответственно через `this` мы можем обращаться внутри класса к любым его членам (зачастую это НЕ требуется делать). Явное использование `this` затрудняет понимание вашего кода. Использовать `this` явно советуется только при разработке шаблоннов класса и в ограниченном случае.

**ВАЖНО**
Избегайте ситуаций следующего вида:
```cpp
class Point {
  float x;
  float y;
  Point(float x, float y) {
    this->x = x;
    this->y = y;
  }
};
```
В примере выше имена полей класса и имена аргументов совпадают. И разработчику приходится явно использовать ключевое слово `this`, чтобы решить неясность в коде кто кому присвоится. Использование слова `this` не является идеальным решением проблемы. Лучшее решение - избавиться от дублирующих имен. 

### Методы класса
Чтобы взаимодействовать с классом используют методы класса - функции, которые имеют доступ к закрытым полям класса.

Методы бывают **константными** и **не константными**. Константный метод не может изменять поля класса. Такие методы могут только читать поля (исключением состаяют `mutable` поля).

Если концептуально метод не должен изменять класс, то его следует объявлять константным! Например, методы `size()` у класса `std::string` не должен никак менять саму строку, поэтому он объявляется константным:
```cpp
size_t string::size() const`
```

В каждый *не статический* метод класса первым аргументом **неявно** передается указатель на текущий объект (тот самый `this`). Именно благодаря этому, программа понимают к какому именно объекту идет обращение.

```cpp
// первым арументом неявно (поэтому и закомментирован) передается неизменяемый указатель на объект класса.
void string::push_back( /* std::string* const this*/ char ch ); 
```

*Замечание*
Отметим, что `this` - это неизменяемый указатель (`MyClass *const`), а не указатель на неизменяемый объект (`const MyClass*`).

Кстати, если метод является константным, то `this` будет неизменяемым указателем на константный объект (`const MyClass* const`)

### Конструкторы
Конструктор - специальный метод, который вызывается при **создании** объекта класса. В нем принято инициализировать поля класса.

По сути конструктор представляет функцию, которая может принимать параметры и которая **должна называться по имени класса**.

Есть несколько видов конструкторов:
1. констурктор по умолчанию (не принимает никаких аргументов) `string::string()`
2. констурктор копирования (принимает константную ссылку на объект такого же класса) `string::string(const string&)`
3. констурктор перемещения (принимает rvalue ссылку на объект такого же класса) `string::string(string&&)`. Рассмотрен будет в 3 семестре
4. пользовательский конструктор. Объявляется самим разработчиком, принимает любое количество аргументов и разных типов.

Компилятор может генерировать самостоятельно первые три конструктора (не факт, что он сделает это корректно).
Если в классе определен хотя бы один пользовательский конструктор, то компилятор не станет генерировать конструторы. Подробнее смотри **правило трёх** и **правило пяти**!

### Деструктор
Деструктор - специальный метод, который вызывается при **унижтожении** объекта. В деструкторе требуется освобождать выделенные ресурсы, которые требовались для работы объекта, например, динамическая память и пр ресурсы, требующие освобождения.

*На заметку студенту*
Студенты очень любят писать следующий код:
```cpp
~MyClass() {
  var_a = 0;
  var_b = 0;
  ptr = nullptr;
  // ...
}
```
Т.е. студенты по какой-то причине считают, что есть скрытый смысл в обнулении полей класса. В большинстве случае это лишь захламляет код. Не надо так делать, без сильных обоснований.

### Перегрузка операторов
В качестве "синктатического сахара" в С++ разрешена перегрузка операторов класса. Чаще всего к перегрузке прибегают для удобства разработчика. Правда же соединить две строки убоднее и вырачительнее через `оператор +`, чем прибегать к какому-то специальному методу.

В перегрузках операторов особняком стоят перегрузка присваивания `operator=`.

#### Перегрузка присваивания
Эти операторы вызываются, когда разработчику требуется присвоить один объект другому.
```cpp
name_one = name_two;
```

Есть два вида таких операторов:
1. Оператор присваивания (или копирования) - присваивает правый операнд левому. 
Принимает константную ссылку на объект. Возвращает ссылку на левый операнд.
```cpp
string& operator=(const string& oth);
```
Возвращает ссылку на левый операнд, чтобы возможно было написать код вида `a = b = c = d;`.

Так же в реализации этого оператора принято проверять, что левый и правый операнды не являются одним и тем же объектом.
```cpp
string name;
string& ref = name;
name = ref;
```

Типичный оператор присваивания выглядит так:
```cpp
ClassName& operator=(const ClassName& rhs) {
  if (&rhs != this) {
    // реализация присваивания.
    ...
  }
  return *this;
}
```

2. Оператор перемещения - перемещает правый операнд в левый. Будет рассмотрен в следующем семестре.

#### Перегрузка остальных операторов
В перегрузке операторов для класса нет ничего сложного или необычного. Оставим на самостоятельное рассмотрение - https://metanit.com/cpp/tutorial/5.14.php

Единственное замечание, которое необходимо дать. Не стоит злоупотреблять перегрузкой операторов. И не надо использовать операторы класса для специфичных задач. Т.е. если вы реализуете свой класс и для него концептуально не применимы различные операторы, то не надо их перегружать. Например, для класса "строки" сложно определить оператор вычитания, поэтому не надо реализовывать этот оператор. Как использовать перегруженные вами операторы для класса должно быть понятно не только вам, но и вашим коллегам. Поэтому настоятельно просим избегать ситуаций, когда только вы знаете, что делает перегруженный оператор.   

## Задание
1. Реализуйте класс `String`. Интерфейс класса объявлен в [string.hpp](include/string.hpp).
2. Реализованный класс должен проходить [unit-тесты](tests/string_unittest.cpp)
3. Разработайте программу для демонстрации работы вашего класса `String` (в функции `main` вызовите все реализованные вами функции и методы)

## Полезные ссылки
* https://metanit.com/cpp/tutorial/5.1.php
* https://metanit.com/cpp/tutorial/5.2.php
* https://metanit.com/cpp/tutorial/5.3.php
* https://metanit.com/cpp/tutorial/5.4.php
* https://metanit.com/cpp/tutorial/5.5.php
* https://metanit.com/cpp/tutorial/5.6.php
* https://metanit.com/cpp/tutorial/5.7.php
* https://metanit.com/cpp/tutorial/5.13.php
* https://metanit.com/cpp/tutorial/5.14.php
* https://metanit.com/cpp/tutorial/5.15.php
